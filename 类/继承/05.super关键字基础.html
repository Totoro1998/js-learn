<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //super()用在构造函数中，super虽然代表了父类A的构造函数，但是返回的是子类B的实例
      //在子类普通方法中通过super调用父类的方法时，父类方法内部的this指向当前的子类实例
      class A {
        constructor() {
          this.x = 1;
        }
      }

      class B extends A {
        constructor() {
          super();
          this.x = 2;
          //由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性
          //super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined
          super.x = 3;
          //super作为对象时，在普通方法中（包括constructor），指向父类的原型对象；在静态方法中，指向父类。
          console.log(super.x); // undefined
          console.log(this.x); // 3
        }
      }

      let b = new B();
    </script>
  </body>
</html>
